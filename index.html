<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>XAUUSD NUCLEAR SMC vC (Real Data + Secure)</title>
  <style>
    :root { --bg:#0b0c0f; --card:#111216; --accent:#06f; --good:#008800; --bad:#880000; --muted:#99a; }
    body{ background:var(--bg); color:#fff; font-family:Inter,system-ui,Arial; padding:20px; margin:0; }
    .wrap{ max-width:900px; margin:0 auto; }
    h1{ margin:0 0 8px; font-size:20px; }
    p.small{ color:var(--muted); margin:6px 0 16px; font-size:14px; }
    button{ padding:10px 16px; border-radius:8px; border:none; background:var(--accent); color:#fff; cursor:pointer; margin:8px 6px 8px 0; font-weight:600; }
    button.stop{ background:#c33; }
    .status{ padding:12px; background:#0d0f12; border-radius:8px; margin-top:12px; font-size:14px; }
    .signalBox{ padding:16px; margin-top:16px; border-radius:12px; display:none; font-weight:600; line-height:1.6; }
    .logs{ background:#000; color:#0f0; padding:12px; height:380px; overflow:auto; border-radius:8px; margin-top:12px; font-family:monospace; font-size:13px; white-space:pre-wrap; }
    .infoRow{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-top:12px; }
    .chip{ background:#0d0f12; padding:6px 12px; border-radius:8px; font-size:13px; }
    .trendRow{ margin-top:12px; display:flex; gap:12px; flex-wrap:wrap; }
    .trendChip{ padding:8px 14px; border-radius:10px; font-weight:700; background:#222; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>XAUUSD NUCLEAR SMC vC</h1>
  <p class="small">Real Data • Refined SMC + Liquidity + MSS + Volume Profile<br>
  <b>5/8 = Early • 6+/8 = Strong Nuclear Signal</b></p>

  <div class="infoRow">
    <button id="startBtn">Start Bot</button>
    <button id="stopBtn" class="stop">Stop Bot</button>
    <div class="chip" id="runStatus">Status: Stopped</div>
    <div class="chip" id="lastSignal">Last Signal: —</div>
  </div>

  <div class="trendRow">
    <div class="trendChip" id="trendChip">Trend: —</div>
    <div class="trendChip" id="strengthChip">Strength: —</div>
  </div>

  <div id="signal" class="signalBox"></div>
  <div class="status" id="summary">Loading config & real XAUUSD data from TwelveData + Metals.live...</div>
  <div class="logs" id="logs"></div>
</div>

<script>
// ==================== CONFIG LOADER (SECURE) ====================
let CONFIG = {};
async function loadConfig() {
  try {
    const res = await fetch('config.json?' + Date.now()); // cache bypass
    CONFIG = await res.json();
    document.getElementById("summary").innerText = "Config loaded • Using real XAUUSD data";
    log("Config loaded successfully");
  } catch (e) {
    document.getElementById("summary").innerText = "ERROR: config.json not found!";
    log("config.json missing! Create it with your API keys");
  }
}

// ==================== REAL DATA FROM TWELVE DATA ====================
async function getRealCandles(timeframe = "15min", limit = 200) {
  const key = CONFIG.twelvedata_api_key;
  if (!key) return null;

  const url = `https://api.twelvedata.com/time_series?symbol=XAU/USD&interval=\( {timeframe}&outputsize= \){limit}&apikey=${key}&dp=2`;
  try {
    const r = await fetch(url);
    const j = await r.json();
    if (j.status === "error") throw new Error(j.message);
    
    return j.values.map(c => ({
      o: parseFloat(c.open),
      h: parseFloat(c.high),
      l: parseFloat(c.low),
      c: parseFloat(c.close),
      v: parseFloat(c.volume || 1000)
    })).reverse(); // oldest first
  } catch (e) {
    log("TwelveData Error: " + e.message);
    return null;
  }
}

// Fallback real-time price from metals.live
async function getLivePrice() {
  const key = CONFIG.metals_api_key;
  if (!key) return null;
  
  const url = `https://api.metals.live/v1/spot`;
  try {
    const r = await fetch(url);
    const data = await r.json();
    const xau = data.find(x => x.symbol === "XAUUSD" || x.metal === "gold");
    return xau ? xau.price : null;
  } catch {
    return null;
  }
}

// ==================== SMC INDICATORS (REAL) ====================
const COOLDOWN_MS = 60 * 60 * 1000; // 1 hour
const VOLUME_MULT = 2.3;
const WICK_ATR_MULT = 1.15;
const RR = 4;

let lastSignalTime = 0;
let running = false;
let loopId = null;

const logsEl = document.getElementById("logs");
const trendChip = document.getElementById("trendChip");
const strengthChip = document.getElementById("strengthChip");
const lastSignalEl = document.getElementById("lastSignal");
const signalBox = document.getElementById("signal");

function log(msg) {
  logsEl.innerText += `[\( {new Date().toLocaleTimeString()}] \){msg}\n`;
  logsEl.scrollTop = logsEl.scrollHeight;
}
function fmt(n) { return Number(n).toFixed(2); }

function ATR(candles, period = 14) {
  if (candles.length < period + 1) return 0;
  let tr = [];
  for (let i = 1; i < candles.length; i++) {
    const prev = candles[i-1];
    const curr = candles[i];
    const trVal = Math.max(
      curr.h - curr.l,
      Math.abs(curr.h - prev.c),
      Math.abs(curr.l - prev.c)
    );
    tr.push(trVal);
  }
  let atr = tr.slice(0, period).reduce((a,b) => a+b, 0) / period;
  for (let i = period; i < tr.length; i++) {
    atr = (atr * (period - 1) + tr[i]) / period;
  }
  return atr;
}

function detectOrderBlock(candles) {
  let bull = null, bear = null;
  for (let i = 5; i < candles.length - 2; i++) {
    const prev = candles[i-1];
    const curr = candles[i];
    if (prev.c < prev.o && curr.c > curr.o && curr.c > prev.h && curr.l <= prev.l) {
      bull = { price: prev.l, index: i };
    }
    if (prev.c > prev.o && curr.c < curr.o && curr.c < prev.l && curr.h >= prev.h) {
      bear = { price: prev.h, index: i };
    }
  }
  return { bull, bear };
}

function detectFVG(candles) {
  for (let i = 2; i < candles.length; i++) {
    const a = candles[i-2], b = candles[i];
    if (a.h < b.l) return "bullish";
    if (a.l > b.h) return "bearish";
  }
  return null;
}

function isVolumeSpike(candles) {
  if (candles.length < 20) return false;
  const lastVol = candles[candles.length-1].v;
  const avgVol = candles.slice(-20, -1).reduce((a,c) => a + c.v, 0) / 19;
  return lastVol > avgVol * VOLUME_MULT;
}

function detectMSS(candles, lookback = 30) {
  const recent = candles.slice(-lookback);
  const highest = Math.max(...recent.map(c => c.h));
  const lowest = Math.min(...recent.map(c => c.l));
  const last = candles[candles.length-1];
  if (last.h > highest && last.c < last.o) return "bearish";
  if (last.l < lowest && last.c > last.o) return "bullish";
  return null;
}

function detectLiquidityGrab(candles) {
  const recent = candles.slice(-25);
  const swingHigh = Math.max(...recent.map(c => c.h));
  const swingLow = Math.min(...recent.map(c => c.l));
  const last = candles[candles.length-1];
  const atr = ATR(candles, 14);

  const upperWick = last.h - Math.max(last.o, last.c);
  const lowerWick = Math.min(last.o, last.c) - last.l;

  const topGrab = last.h >= swingHigh && upperWick > atr * WICK_ATR_MULT && last.c < last.o;
  const bottomGrab = last.l <= swingLow && lowerWick > atr * WICK_ATR_MULT && last.c > last.o;

  return { top: topGrab, bottom: bottomGrab, volSpike: isVolumeSpike(candles) };
}

// ==================== MAIN SCAN ====================
async function scanOnce() {
  if (!CONFIG.twelvedata_api_key) return log("API key missing");

  const candles15m = await getRealCandles("15min", 200);
  const candles1h = await getRealCandles("1h", 100);
  if (!candles15m || !candles1h) return log("Failed to fetch real candles");

  const price = candles15m[candles15m.length-1].c;
  const atr15 = ATR(candles15m, 14);

  const ob15 = detectOrderBlock(candles15m);
  const ob1h = detectOrderBlock(candles1h);
  const fvg = detectFVG(candles15m);
  const volSpike = isVolumeSpike(candles15m);
  const mss = detectMSS(candles15m, 35);
  const liq = detectLiquidityGrab(candles15m);

  const indicators = [
    !!ob15.bull || !!ob15.bear,
    !!ob1h.bull || !!ob1h.bear,
    !!fvg,
    volSpike,
    !!mss,
    liq.top || liq.bottom,
    liq.volSpike,
    true // Higher timeframe alignment (you can improve this)
  ];

  const score = indicators.filter(Boolean).length;
  let direction = "NEUTRAL";
  let reason = "";

  if (liq.top) { direction = "SELL"; reason = "Liquidity Grab Above"; }
  else if (liq.bottom) { direction = "BUY"; reason = "Liquidity Grab Below"; }
  else if (mss === "bearish") { direction = "SELL"; reason = "Bearish MSS"; }
  else if (mss === "bullish") { direction = "BUY"; reason = "Bullish MSS"; }

  trendChip.innerText = `Trend: \( {direction} \){reason ? '('+reason+')' : ''}`;
  strengthChip.innerText = `Strength: \( {score >= 6 ? 'NUCLEAR' : score >= 5 ? 'Strong' : 'Weak'} ( \){score}/8)`;

  log(`Price \( {fmt(price)} | Score \){score}/8 | Direction ${direction}`);

  if (score >= 5 && (Date.now() - lastSignalTime) > COOLDOWN_MS) {
    const entry = price;
    const sl = direction === "BUY" ? entry - atr15 * 1.3 : entry + atr15 * 1.3;
    const tp = direction === "BUY" ? entry + (entry - sl) * RR : entry - (sl - entry) * RR;

    const msg = `
<b>NUCLEAR XAUUSD SIGNAL</b>
<b>Direction:</b> \( {direction} \){direction === "BUY" ? "BUY" : "SELL"}
<b>Strength:</b> \( {score >= 6 ? "NUCLEAR" : "Strong"} ( \){score}/8)

<b>Entry:</b> <code>${fmt(entry)}</code>
<b>SL:</b> <code>${fmt(sl)}</code>
<b>TP:</b> <code>${fmt(tp)}</code>
<b>RR:</b> 1:${RR}

${new Date().toLocaleString()}
    `;

    await sendTelegram(msg);

    lastSignalTime = Date.now();
    lastSignalEl.innerText = "Last: " + new Date().toLocaleTimeString();
    signalBox.style.display = "block";
    signalBox.style.background = direction === "BUY" ? "var(--good)" : "var(--bad)";
    signalBox.innerHTML = msg.replace(/\n/g, "<br>");
  }
}

// ==================== TELEGRAM ====================
async function sendTelegram(text) {
  const token = CONFIG.telegram_token;
  const chats = CONFIG.telegram_chats?.split(",").map(c => c.trim()) || [];

  if (!token || chats.length === 0) return log("Telegram not configured");

  for (const chat of chats) {
    const url = `https://api.telegram.org/bot${token}/sendMessage`;
    try {
      await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ chat_id: chat, text, parse_mode: "HTML" })
      });
      log(`Signal sent to ${chat}`);
    } catch (e) {
      log("TG Error: " + e.message);
    }
  }
}

// ==================== START/STOP ====================
document.getElementById("startBtn").onclick = async () => {
  if (running) return;
  await loadConfig();
  if (!CONFIG.twelvedata_api_key) return;
  
  running = true;
  loopId = setInterval(scanOnce, 60 * 1000);
  document.getElementById("runStatus").innerText = "Status: Running";
  log("NUCLEAR SMC Bot Started");
  scanOnce();
};

document.getElementById("stopBtn").onclick = () => {
  clearInterval(loopId);
  running = false;
  document.getElementById("runStatus").innerText = "Status: Stopped";
  log("Bot Stopped");
};

// Auto load config on start
loadConfig();

</script>
</body>
</html>